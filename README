Morph allows you generate class definitions via calling assignment methods. Unlike OpenStruct, it's not a wrapper around a hash, but instead adds methods to a class. Mix with Hpricot for screen scrapping fun.

Here's example code showing Morph playing with Hpricot:

  require 'hpricot'; require 'open-uri'; require 'morph'

  class Hubbit
    include Morph  # allows class to morph

    def initialize name
      doc = Hpricot open("http://github.com/#{name}")

      (doc/'label').collect do |node|
        label = node.inner_text
        value = node.next_sibling.inner_text.strip

        morph(label, value) # magic morphing happening here!
      end
    end
  end

  def Hubbit name; Hubbit.new name; end

The model emerges from the data. Let's start by looking up 'why':

  why = Hubbit 'why'

Let's see what new methods we have:

  Hubbit.morph_methods # => ["email", "email=", "name", "name="]

Ah-ha, so we have a name attribute now:

  why.name #=> "why the lucky stiff"


Let's do some more morphing:

  dhh = Hubbit 'dhh'

What methods do we have now:

  Hubbit.morph_methods # => ["blog", "blog=", "company", "company=",
                             "email", "email=", "location", "location=",
                             "name", "name="]

So dhh's company is:

  dhh.company #=> "37signals"


Time to print the nascent method definition:

  puts Hubbit.print_morph_methods
  # attr_accessor :name
  # attr_accessor :email
  # attr_accessor :blog
  # attr_accessor :company
  # attr_accessor :location

