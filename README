Morph allows you to emerge class definitions via calling assignment methods.
Mix with Hpricot for screen scrapping fun.

== Morph example

Here's example code showing Morph playing with Hpricot:

 require 'hpricot'; require 'open-uri'; require 'morph'

 class Hubbit
   include Morph  # allows class to morph

   def initialize name
     doc = Hpricot open("http://github.com/#{name}")

     (doc/'label').collect do |node|
       label = node.inner_text
       value = node.next_sibling.inner_text.strip

       morph(label, value) # morph magic happening here!
     end
   end
 end

 def Hubbit name; Hubbit.new name; end


The model emerges from the data. Let's start by looking up 'why':

 why = Hubbit 'why'

What new methods do we have?

 Hubbit.morph_methods # => ["email", "email=", "name", "name="]

Ah-ha, so we have a name attribute now:

 why.name #=> "why the lucky stiff"


Let's add some of why's projects:

 why.projects = %w[shoes hacketyhack camping hoodwinkd hpricot markaby mousehole parkplace poignant sandbox]

That why's a productive fellow! Note new accessor methods have been added:

 Hubbit.morph_methods # => ["email", "email=", "name", "name=", "projects", "projects="]


Let's do some more morphing:

 dhh = Hubbit 'dhh'

Do we have more methods now?

 Hubbit.morph_methods # => ["blog", "blog=", "company", "company=", "email", "email=", "location", "location=" "name", "name=", "projects", "projects="]

So, a new company method has appeared:

 dhh.company #=> "37signals"


Time to print the nascent attribute definitions:

 puts Hubbit.print_morph_methods

 # attr_accessor :name
 # attr_accessor :email
 # attr_accessor :blog
 # attr_accessor :company
 # attr_accessor :location
 # attr_accessor :projects


See examples/ directory for more example code.
See LICENSE for the terms of this software.


